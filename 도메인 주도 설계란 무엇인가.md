# 도메인 주도 설계란 무엇인가?

# 1. 도메인 주도 설계란 무엇인가?

자동화된 비즈니스 프로세스나 현실 세계의 문제가 소프트웨어의 도메인이다.

소프트웨어의 전반적인 목적은 특정 도메인의 일이 더 잘굴러가도록 하는 데 있다.

## 도메인과 조화를 이루는 소프트웨어는 어떻게 하면 만들 수 있을까?

→ 소프트웨어는 도메인의 핵심 개념과 각 구성 요소를 담고 이어야 하고 그들 간의 관계를 정확하게 실체화해야 한다. (모델링)

→ 업무를 모르는 사람도 단지 도메인 모델로 작성된 코드를 읽을 경우 공부할 수 있어야 한다.

## 모델이란?

→ 도메인을 추상화하여 표현한 것을 의미 

(다이어그램, 유스케이스, 그림, 사진 등)

→ 도메인의 특정 이슈를 알 릴 수 있는 언어가 필요

## 소프트웨어 설계

### 폭포수 설계 방법

전통적인 소프트웨어 설계 방법 

단계별로 업무를 넘겨 받게 됨

단점 : 분석가로 부터 업무 전문가, 또는 개발자로부터 분석가에게 전달되는 피드백이 전무

### 애자일 설계 방법

폭포수와는 반대되는 집단 움직임

단점 : 설계에 내재된 오류나 부작용들을 사전에 예측할 수 없다. 

분석 마비 : 설계 결정을 내리는 일을 너무나도 두려워한 나머지 전혀 진도가 나가지 못하는 현상

결론 : 도메인과 소프트웨어는 철저하게 혼합이 되어야 하며 그 과정에서 도메인 전문가와 설계자는 모델을 통해 대화 또는 만남의 장소가 되어야 한다.

# 2. 유비쿼터스 언어

개발자는 현실 세계를 프로그램으로 매핑하려는 경향을 지닌다.

도메인 전문가는 자신의 특화된 분야에 대해서만 전문가일 뿐이다.

우리는 모델을 만들 때, 모델에 대한 아이디어 , 포함 되어야 할 요소, 그것들을 어떻게 연결할 것인지, 어던 것들이 관계가 있고 어떤 것들이 관계가 없는지 같은 정보를 교환 해야 한다.

→ 의사소통이 필요!!

도메인 주도 설계의 핵심 원칙은 모델 기반의 언어를 사용하는 것!

모델은 소프트웨어와 도메인이 서로 교차하는 지점이기 때문에 모델 기반 언어를 사용하는 것이 가장 중요하다.

→ 유비쿼터스 언어라고 표현

UML

UML이 모델을 만들기에 충분하다고 하지만 프로젝트 규모가 커지면 표현 방법이 힘든 부분이 있음

- 노트 표기법을 사용하여 제약조건 등 추가 설명에 대한 표기가 필요함

결론 : 소프트웨어 아키텍트, 개발자, 도메인 전문가로 구성된 설계팀은 자신들의 동을 통합하고, 모델 작성과 작성된 모델의 코드화를 도와줄 언어가 필요하다.

# 3. 모델 주도 설계

기본적으로 우리는 비즈니스 도메인에 깊이 뿌리내린 모델을 만들어야 하며, 핵심 개념을 매우 정확하게 반영하는 모델을 만들어야 한다.

분석적으로 정확한 모델을 가지고 있다는 것이 모델을 코드로 바로 변환할 수 있음을 의미하지는 않는다.

중요한 것은 쉽고 정확하게 코드로 변환할 수 있는 모델을 선택하는 것이다.

분석 모델

코드 설계에서 분석을 분리하고, 분석과 코드 설계를 보통 서로 다른 사람이 작업하도록 한다.

분석 모델은 비즈니스 도메인 분석의 결과물일 뿐이고, 소프트웨어 구현은 염두하지 않는다.

단점 : 분석가들이 분석 모델에 내재된 결함이나 도메인 자체의 복잡성을 미리 알 수 없다.

→ 개발자들은 스스로의 의지에 따라 어떤 결정을 내려야만 하는 상황에 놓이게 되고, 처음 모델과는 다르게 될 수 있다.

분석 모델과 코드 설계를 분리하는 것보다 좀 더 나은 접근 방식은 도메인 모델링과 설계를 밀접하게 관련 시키는 것이다.

→ 설계 작업이 직관적이면서 모델을 기반으로 수행되도록 소프트웨어로 정확하게 표현할 수 있는 모델을 선택하는 것! 

→ 개발자들을 피드백 제공자로 동참 시켜라!

모든 개발자도 모델을 주제로 일정 수준의 논의에는 반드시 참여해야 하고, 도메인 전문가와 만나야 한다.

- 새롭게 투입된 개발자가 도메인에 대한 깊숙한 이해는 쉽지 않다고 생각함, 하지만 개발자가 개발을 시작하기 전에 도메인 전문가(기획자)를 만나 설명을 듣는 것은 좋다고 생각이 된다.

객체지향 언어의 사용 필요성 → 모델이 같은 패러다임을 가지고 있고 절차지향 언어로는 한계가 있음

## 계층형 아키텍처

응용 시스템의 상당 부분은 도메인과 직접적인 관련이 없다.

인프라스트럭처나 소프트웨어를 지원하는 제반 환경에 관련된 것들이 소프트웨어의 큰 부분을 차지한다.

따라서 복잡한 프로그램은 ‘레이어’로 분할해야 한다. 각 레이어 내부에서 설계를 수행하여 응집도 높고 자기 하위 레이어에만 의존하도록 만들어야 한다.

| 사용자 인터페이스 | 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다. |
| --- | --- |
| 애플리케이션 레이어 | 애플리케이션 활동을 조율하는 얇은 레이어다. 업무 로직을 포함하지 않는다. 비즈니스 객체의 상태를 보관하지 않지만, 애플리케이션 작업의 처리 상태는 보관한다. |
| 도메인 레이어 | 도메인 정보를 포함한다. 업무 소프트웨어의 심장에 해당한다. 비즈니스 객체의 상태를 포함한다. 비즈니스 객체와 이 객체의 상태 정보 중 가능한 부분의 영속성에 대한 책임은 인프라스트럭처 레이어로 위임된다. (비즈니스 객체와 그들의 상태를 영속화 하는 책임은 인프라스트럭처 레이어로 위임된다.) |
| 인프라스트럭처 레이어 | 다른 레이어 모두를 지원하는 라이브러리로 동작한다. 레이어 간의 통신을 제공하고 비즈니스 객체의 영속성을 구현하고 사용자 인터페이스의 라이브러리를 포함한다. |

## 엔티티

소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지는 식별자를 지니는 유형의 객체

(식별자가 없으면 엔티티가 아니다)

시스템에 서 식별자가 같은 두 객체는 같다고 간주한다.

(예: Customer, Person)

## 값 객체

식별자가 없으며 정보성으로 제공하는 객체

수정 불가능하며 식별자가 없는 값 객체는 공유될 수 있다.

엔티티의 정의에 부합하는 객체만을 엔티티로 선택하기를 권한다.

(예: Point, Address)

## 서비스

도메인 분석하여 모델을 구성하는 주요 객체를 정의하려고 할 때 도메인의 어떤 부분들은 객첼 ㅗ쉽게 매핑될 수 없다는 사실을 발견하게 된다.

동사는 보통 객체의 행위 부분이 되는데 어떤 행동이나 일부 동사는 어느 객체에도 속하지 않게 된다. 

→ 이런 유형은 서비스로 정의 하는 것이 좋다.

### 서비스 특징

- 상태는 가지지 않으면서, 단순히 도메인에 기능을 제공하는 목적을 지닌다.
- 서비스가 제공하는 기능은 매우 중요하고, 서비스는 엔티티와 값 객체에 기여하는 관련된 기능들을 묶을 수 있다.
- 서비스는 하나의 개념으리 캡슐화하여 도메인에 명확하게 구분되어 만들어지기 때문에, 명시적으로 선언하는 편이 좋다.

### 서비스는 어떤 계층에 있어야 할까?

1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값객체에 속할 수 없는 도메인 개념을 나타낸다.
2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.
3. 오퍼레이션은 상태를 저장하지 않는다.

만약 오퍼레이션이 개념적으로 애플리케이션 레이어에 속하는 일을 수행한다면 해당 서비스는 그 레이어에 존재하는 것이 맞고 도메인에 필요한 것을 제공한다면 도메인 레이엉에 속하도록 해야한다.

## 모듈

모듈화 → 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다.

모델들이 커지게 되면 모델을 모듈로 나누어 구조화 할 필요가 있다.

대규모 모델일지라도 모델에 속해 있는 모듈과 이들 간의 관계를 중심으로 본다면 그 개요를 파악하기 쉬워진다.

모듈들 간의 상호작용이 이해되었다면 그때부터 모듈 하나하나의 내부를 파악하기 시작하면 된다.

코드는 높은 응집도와 낮은 결합도를 추구해야 한다.

→ 모듈 사용을 권장

통신 응집도(communicational cohesion)

→ 모듈의 일부가 같은 데이터르르 다룰 때 얻을 수 있다.

기능 응집도(functional cohesion) 👍

→ 모듈의 모든 부분이 잘 정의된 임무를 수행하고 있을 때 얻을 수 있다.

모듈 하나가 다수의 다른 모듈과 연관되어 있는 것보다 잘 정의된 임무를 수행하는 모듈끼리 연결 고리가 별로 없을 때 이해하기가 더 수월하다

모듈의 역할이 결정되고 나면 모듈 내부에는 변경이 많이 일어나는 반면에 모듈이 제공하는 내용 자체는 변경되지 않는 경향을 보인다. 

→ 모듈을 최종 확정 시키지는 말고 프로젝트와 함께 진화시켜 나가기를 권장

## 집합

도메인 객체의 생명주기

집합은 객체소유권과 경계를 정의하는 데 사용되는 패턴

팩토리와 리파지토리는 객체의 생성과 저장을 도와주기 위한 설계 패턴이다.

모델에서 도전과제는 완성도를 충분히 갖춘 모델을 작성하는데 있다기 보다 어떻게 해야 모델을 단순하고 이해하기 쉽게 만들 수 있느냐에 있다.

관계에 참여하는 객체의 숫자는 가능한 최소화

1. 모델의 핵심 사항이 아닌 관계가 있다면 관계를 제거
2. 다수성의 숫자는 제약사항을 추가하여 감소
3. 많은 경우 양방향 관계는 단방향 관계롤 대체될 수 있다.

### 집합

집합 → 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체들의 집합

각 집합에는 하나의 root를 가지게 된다.

- 고객 집합 예시
    
    고객 (root) 고객정보, 주소 
    

root는 다른 객체들을 변경할 수 있지만 이러한 변경은 집합 안에  포함된 오퍼레이션이다.

다른 객체들은 root를 바꾸거나, root에게 어떤 행동을 수행하라고 요청할 수 있다.

root 가 삭제 될 경우 하위 객체도 자동 삭제

다른 집합의 객체들은 root를 참조할 수 있어야 한다. (데이터 접근이 root만 가능하기 때문)

## 팩토리

팩토리 → 복잡한 객체 생성의 절차를 캡슐화 할 수 있는 새로운 개념

중요한 것은 생성 절차를, 쪼갤 수 없는 원자적인 상태로 만들어야 한다.

팩토리 메소드 패턴, 추상적인 팩토리

팩토리메서드는 다른 객체를 생성하는 데 필요한 지식을 포함하지만 외부에 들어내지 않는 객체 메서드

root객체의 생성은 집합에 속해 있는 객체들의 생성과 연관되어 있기 때문에 일정한 로직이 추가가 됨.

로직의 어떤 객체에도 추가되지 않기 때문에 factory에 추가되는 것이 맞다.

생성이 복잡하지 않는 경우에는 팩토리 대신 생성자를 사용한다.

## 레파지토리

도메인 모델이 객체의 저장이나 참조와 연관을 없애고 하부의 영속성을 보장하는 인프라스트럭처에 접근할 필요가 없도록 하는 것이 리파지토리의 전반적인 역할

# 4장 깊은 통찰을 향한 리팩터링

## 지속적인 리팩터링

모델은 자신의 바탕이 되는 도메인과 매우 밀접하게 관련되어 있어야 한다.

모델이 설계 결정에 기반하여 개선되어야 한다는 것도 잘 알고 있다.

리팩터링 : 애플리케이션의 기능에 변화를 주지 않고 코드를 더 좋게 만들기 위해 재설계하는 절차

→ 코드를 나쁘지 않게, 더 낫게 만드는 작업

패턴을 기반으로 하는 기술적인 리팩터링은 조직화되고 구조화 된다.

그러나 깊은 통찰을 향한 리팩터링은 이러한 방식으로는 수행할 수 없다.

## 핵심 개념 드러내기

리팩터링은 작은 단계로 나누어 진행되며, 그 결과 또한 작은 개선의 연속으로 나타난다.

소규모의 변경이 큰 차이를 초래하는 경우도 있다. → 도약

도약에 도달하려면 암시적 개념을 명시적으로 만들 필요가 있다.

암시적 개념 : 유비쿼터스 언어로 변환되지 않은 나머지들

(이미 명시된 개념들을 설명할 때 사용되기도 함)

암시적 개념 발견한 경우 이를 명시적으로 만들어라.

설계를 단순하고 유연하게 만들기 위해 리팩터링 한다.

명시적인 것을 만들어 낼 때 유용한 추가 개념들

- 제약조건(Constraint)
    - 제약조건은 메서드로 분리하며 제약 사항이 명확해 지는 장점이 있고 나중에 조건 추가가 되기도 쉽다.
- 처리(Process)
    - Service를 이용
    - 구현 방법이 여러가지 라면 전략패턴
- 명세(Specification)
    - 객체가 특정 기준을 만족하는지 여부를 확인하는 목적

![[Pasted image 20231210142949.png]]